### FILENAME:
  server.js
### CONTENT
// IMPORT MAJOR PACKAGES
require('dotenv').config(); // load .env

// HTTPS SUPPORT
const https = require('https'); // import https for attaching the app server ontop of https
const fs = require('fs'); // import fs for reading cert files

// Read SSL certificate
const privateKey = fs.readFileSync('./ssl/key.pem', 'utf-8');
const certificate = fs.readFileSync('./ssl/cert.pem', 'utf-8');
const credentials = { key: privateKey, cert: certificate };

const express = require("express") // import express framework
const morgan = require("morgan") // import morgan debuger
const cors = require("cors") // import cors middleware
const { log } = require('mercedlogger') // import mercedlogger's log function
const bodyParser = require("body-parser") // import body-parser middleware
 
// ENV VARIABLES WITH DEFAULT VALUES
const { PORT = 3001 } = process.env // get port from .env

// APPLICATION OBJECT
const app = express() // create express app

// GLOBAL MIDDLEWARE
app.use(cors()) // use cors middleware
app.use(morgan("dev")) // use morgan debuger
app.use(bodyParser.urlencoded({ extended: true})) // use body-parser middleware
app.use(bodyParser.json()) // use body-parser middleware JSON output

// CREATE CONTEXT GLOBALLY
const { createContext } = require("./middlewares/global")
app.use(createContext);

// Prevent app from crashing if validation fails MIDDLEWARE | to be combined with express-validator for forms
app.use((err, req, res, next) => { // catch the error stack if it exists within a req chain
    console.error(err.stack);
    res.status(500).json({ error: 'Something went wrong!' });
  });

  // ROUTES
app.get("/", (req, res) => {
    res.send("Hello from the API Server!")
})
// import user routes / controller
app.use("/user", require("./controllers/User"));

// import isloggedin middleware
const { isLoggedIn } = require("./middlewares/global");
const { createPrivateKey } = require('crypto');
// test protected route
app.get("/protected", isLoggedIn, (req, res) => {
    res.json({
        message: "Protected route. You need to be logged in to access this route!"});
});

// Create HTTPS server
const httpsServer = https.createServer(credentials, app);

// APP LISTENER
httpsServer.listen(PORT, () => log.green("SERVER STATUS", `Listening on port ${PORT}`))
###

### FILENAME:
  controllers/User.js
### CONTENT
require("dotenv").config(); // import dotenv
const { Router } = require('express'); // import express router
const bcrypt = require("bcrypt"); // import bcrypt
const jwt = require("jsonwebtoken"); // import jsonwebtoken
const { body, validationResult } = require("express-validator"); // import express-validator

const router = Router(); // create express router for route bundle

//ENV VARIABLES WITH DEFAULTS
const { SECRET } = process.env;

//RATE LIMITER FOR AVOIDING BRUTFORCE ATTACKS
const rateLimit = require('express-rate-limit');
const { log } = require('mercedlogger');
const { isLoggedIn, revokeToken } = require("../middlewares/global");

const loginLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 min
    max: 5, // limit each IP to 5 requests per windowMs
    message: 'Too many login attempts from this IP, please try again after 15 minutes'
});

const refreshLimiter = rateLimit({
    windowMs: 60 * 60 * 1000, // 1 hour
    max: 10, // limit each IP to 10 requests per windowMs
    message: 'Too many refresh attempts from this IP, please try again after 1 hour'
});

//Signup test route
router.get("/signup", (req, res) => {
    res.json({ message: "Signup route. Use POST statement with username and password to register!" });
})

//Signup post - create new user
router.post("/signup", [
    //validation of username and password fields
    body("username").notEmpty().withMessage("Username cannot be empty!"),
    body("password").notEmpty().withMessage("Password cannot be empty!")
], async (req, res) => {
    // Check validation results
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }    

    //import context model for User
    const { User } = req.context.models;

    //create user object
    try {
        //check if user already exists
        if (await User.findOne({ username: req.body.username })) {
            return res.status(400).json({ error: "User already exists!" });
        }

        // hash the password
        req.body.password = await bcrypt.hash(req.body.password, 10);
        // create a new user
        const user = await User.create(req.body);
        // send new user as response
        res.json(user);
    } catch (error) {
        res.status(500).json({ error: "Something went wrong!" });
    }
});

//Login route to verify a user and get a token
router.post("/login", loginLimiter, [
    //validation of username and password
    body("username").notEmpty().withMessage("Username cannot be empty!"),
    body("password").notEmpty().withMessage("Password cannot be empty!")
], async (req, res) => {
    // Check validation results
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }    

    //import context model for User
    const { User } = req.context.models;
    try {
        // check if user exists
        const user = await User.findOne({ username: req.body.username });
        // log login-attempt by anyone
        log.red("LOGIN", `Login attempt by ${req.body.username}`);

        //handle user
        if (user) {
            //check if password matches
            const result = await bcrypt.compare(req.body.password, user.password);
            if (result) {
                //sign token and send it in response
                const token = jwt.sign({ username: user.username }, SECRET, {
                    algorithm: "HS256", // algorithm used for header and payload encryption
                    allowInsecureKeySizes: true, // allow bigger key sizes - will check later what it exactly mean
                    expiresIn: "8h" // token will expire in 8 hours
                });

                //log user for reference
                log.yellow("LOGIN", `User ${user.username} logged in!`);
                
                //add token to user object
                user.token = token;

                //save object and send both (token, user) in response
                await user.save();
                res.json({ token, user });
            } else {
                // if passwords do not match
                res.status(401).json({ error: "Passwords do not match!" });
            }
        } else {
            // if user does not exist
            res.status(401).json({ error: "User not found!" });
        }
    } catch (error) {
        // if something went wrong
        res.status(500).json({ error: "Something went wrong!" });
    }
});

router.post("/logout", isLoggedIn, (req, res) => {
    //receive token from the header, remove bearer argument
    const token = req.headers.authorization.split(" ")[1];
    //if token is valid, revoke it
    revokeToken(token);
    res.json({ message: `User ${req.user.username} logged out!` });
});

module.exports = router;
###

### FILENAME:
  middlewares/db.connection.js
### CONTENT
require("dotenv").config() // load .env variables
const mongoose = require("mongoose") //import fresh mongoose object
const {log} = require("mercedlogger") // import merced logger

//DESTRUCTURE ENV VARIABLES
const {DATABASE_URL} = process.env 

// CONNECT TO MONGO
mongoose.connect = mongoose.connect(DATABASE_URL)

// CONNECTION EVENTS
mongoose.connection
.on("open", () => log.green("DATABASE STATE", "Connection Open"))
.on("close", () => log.magenta("DATABASE STATE", "Connection Open"))
.on("error", (error) => log.red("DATABASE STATE", error))

// EXPORT CONNECTION
module.exports = mongoose
###

### FILENAME:
  middlewares/global.js
### CONTENT
require("dotenv").config(); // importing dotenv
const jwt = require("jsonwebtoken"); // importing jsonwebtoken

const User = require("../models/User"); // importing user model
const { log } = require('mercedlogger'); // importing mercedlogger's log function

// SET SECRET FOR JWT
const { SECRET } = process.env;

const createContext = (req, res, next) =>  {
    // making objects accessable to all routes
    req.context = {
        models: {
            User
        }
    }
    log.green("CONTEXT", "Context created");
    next();
}

// BLACKLISTED TOKEN SET
const tokenBlacklist = new Set();
const revokeToken = (token) => {
    tokenBlacklist.add(token);
}

const isLoggedIn = async (req, res, next) => {
    try {
        if (req.headers.authorization) {
            // check if token exists, exclude word bearer
            const token = req.headers.authorization.split(" ")[1];
            if (token) {
                if (tokenBlacklist.has(token)) {
                    return res.status(401).json({ error: "Token is blacklisted!" });
                }
                const payload = await jwt.verify(token, SECRET);
                if (payload) {
                    req.user = payload;
                    log.green("TOKEN", "Token verified");
                    next();
                } else {
                    // invalid token
                    res.status(401).json({ error: "Token is invalid!" });
                }
            } else {
                // malformed header
                res.status(401).json({ error: "Malformed auth header" });
            }
        } else {
            // invalid header
            res.status(401).json({ error: "No auth header provided" });
        }
    } catch (error) {
        // verification error
        //console.error("Token error", error);
        log.red("TOKEN", "Token verification failed!");
        res.status(401).json({ error: "Token verification failed!" });

    }
}

// EXPORT MIDDLEWARE
module.exports = {
    createContext,
    isLoggedIn,
    revokeToken
}
###

### FILENAME:
  models/User.js
### CONTENT
const {Schema, model} = require("../middlewares/db.connection") // import Schema & model

// User Schema
const UserSchema = new Schema({
    username: {type: String, unique: true, required: true},
    password: {type: String, required: true},
    token: {type: String}
})

// User model
const User = model("User", UserSchema)

module.exports = User
###

### FILENAME:
  .env
### CONTENT
PORT=3001
DATABASE_URL=mongodb://admin:Sql2024!@vdocker:27017/inv-api?authSource=admin
SECRET=some-special-secret-super-key
###

### FILENAME:
  package.json
### CONTENT
{
  "name": "api",
  "version": "0.0.1",
  "description": "API Backend Server Boilerplate",
  "main": "server.js",
  "scripts": {
    "test": "nodemon server.js",
    "start": "node server.js"
  },
  "author": "Dominic Messner",
  "license": "ISC",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "body-parser": "^1.20.2",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-rate-limit": "^7.3.1",
    "express-validator": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "mercedlogger": "^1.0.1",
    "mongoose": "^8.4.4",
    "morgan": "^1.10.0",
    "nodemon": "^3.1.4"
  }
}

###

### FILENAME:
  README.md
### CONTENT
Inventory API Endpoint
###

